name: Lambda and API Gateway Deployment with Tests

on:
  push:
    branches:
      - main   # Trigger deployment on push to the main branch

jobs:
  # Job for running unit, security, and performance tests before deployment
  test:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Set up Python environment
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Step 3: Install dependencies
      - name: Install dependencies
        run: |
          pip install -r CHANGI_BACKEND/lambda-layer/requirements.txt

      # Step 4: Run Unit Tests (with pytest)
      # - name: Run Unit Tests
      #   run: |
      #     cd CHANGI_BACKEND
      #     python -m pytest > unit-test-report.txt

      # Step 5: Upload Unit Test Results
      - name: Upload Unit Test Results
        uses: actions/upload-artifact@v3
        with:
          name: unit-test-report
          path: unit-test-report.txt

      # Step 6: Install Bandit for Security Testing
      - name: Install Bandit
        run: |
          pip install bandit

      # # Step 7: Run Bandit Security Scan
      # - name: Run Bandit Security Scan
      #   run: |
      #     cd CHANGI_BACKEND
      #     bandit -r . --exclude lambda-layer,tests -f json -o bandit-report.json

      # # Step 8: Upload Bandit Security Report
      # - name: Upload Bandit Security Report
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: bandit-report
      #     path: bandit-report.json

  # Build and Deploy Job
  build-deploy:
    runs-on: ubuntu-latest
    needs: test  # The deploy job depends on the test job

    steps:
      # Step 1: Checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Set up Python environment
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Step 3: Install AWS CLI and SAM CLI
      - name: Install AWS CLI and SAM CLI
        run: |
          sudo apt-get update
          sudo apt-get install awscli -y
          pip install aws-sam-cli
            
      # Set the deployment stage based on the branch
      - name: Set Stage
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "STAGE=prod" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/test" ]]; then
            echo "STAGE=staging" >> $GITHUB_ENV
          else
            echo "STAGE=dev" >> $GITHUB_ENV

      # Configure AWS credentials
      - name: Configure AWS credentials
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-southeast-1
        run: |
          aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
          aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
          aws configure set default.region $AWS_DEFAULT_REGION

      # Step 4: Install dependencies for the Lambda Layer
      - name: Install Lambda Layer dependencies
        run: |
          cd CHANGI_BACKEND/lambda-layer
          pip install -r requirements.txt -t python  # Install dependencies into python/ folder
          cd ..

      # Step 5: Build the AWS SAM project
      - name: Build the project
        run: |
          sam build --template-file template.yaml

      # Step 6: Deploy the Lambda and API Gateway
      - name: Deploy Lambda and API Gateway
        run: |
          sam deploy --template-file template.yaml --no-confirm-changeset --capabilities CAPABILITY_IAM --stack-name flask-lambda-api \
          --parameter-overrides \
            APIKey=${{ secrets.API_KEY }} \
            AssistantID=${{ secrets.ASSISTANT_ID }} \
            OpenAIKey=${{ secrets.OPENAI_API_KEY }} \
            OpenAIURL=${{ secrets.OPENAI_API_URL }} \
            VectorID=${{ secrets.VECTOR_ID }} \
            StageName=${{ env.STAGE }}

      # Step 7: Extract the API Gateway URL
      - name: Extract API Gateway URL
        id: extract-url
        run: |
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name flask-lambda-api \
            --query "Stacks[0].Outputs[?OutputKey=='ApiUrl'].OutputValue" \
            --output text)
          echo "::set-output name=api_url::$API_URL"
      
  # Performance Testing Job using Jmeter
  # performance:
  #   runs-on: ubuntu-latest
  #   needs: build-deploy

  #   steps:
  #     # Install JMeter
  #     - name: Install JMeter
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y openjdk-11-jre
  #         wget https://downloads.apache.org//jmeter/binaries/apache-jmeter-5.5.tgz
  #         tar -xvzf apache-jmeter-5.5.tgz
  #         sudo mv apache-jmeter-5.5 /opt/jmeter

  #     # Create JMeter Test Plan dynamically with the extracted API URL
  #     - name: Create JMeter test plan
  #       run: |
  #         echo '
  #         <?xml version="1.0" encoding="UTF-8"?>
  #         <jmeterTestPlan version="1.2" properties="5.0" jmeter="5.5">
  #           <hashTree>
  #             <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Performance Test Plan" enabled="true">
  #               <stringProp name="TestPlan.comments"/>
  #               <boolProp name="TestPlan.functional_mode">false</boolProp>
  #               <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
  #               <elementProp name="TestPlan.user_defined_variables" elementType="Arguments"/>
  #               <stringProp name="TestPlan.user_define_classpath"/>
  #             </TestPlan>
  #             <hashTree>
  #               <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group" enabled="true">
  #                 <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
  #                 <elementProp name="ThreadGroup.num_threads" elementType="int">100</elementProp>
  #                 <stringProp name="ThreadGroup.ramp_time">60</stringProp>
  #                 <longProp name="ThreadGroup.duration">600</longProp>
  #                 <boolProp name="ThreadGroup.scheduler">true</boolProp>
  #               </ThreadGroup>
  #               <hashTree>
  #                 <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request" enabled="true">
  #                   <stringProp name="HTTPSampler.domain">${{ steps.get_api_url.outputs.api_url }}</stringProp>
  #                   <stringProp name="HTTPSampler.port">443</stringProp>
  #                   <stringProp name="HTTPSampler.protocol">https</stringProp>
  #                   <stringProp name="HTTPSampler.path">/process-transcribed-text</stringProp>
  #                   <stringProp name="HTTPSampler.method">POST</stringProp>
  #                   <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
  #                   <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
  #                   <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="" enabled="true">
  #                     <collectionProp name="Arguments.arguments">
  #                       <elementProp name="" elementType="HTTPArgument">
  #                         <boolProp name="HTTPArgument.always_encode">false</boolProp>
  #                         <stringProp name="Argument.value">{ "transcribed_text": "Where is the nearest gate?", "language": "English" }</stringProp>
  #                         <stringProp name="Argument.metadata">=</stringProp>
  #                         <boolProp name="HTTPArgument.use_equals">true</boolProp>
  #                         <stringProp name="Argument.name"/>
  #                       </elementProp>
  #                     </collectionProp>
  #                   </elementProp>
  #                 </HTTPSamplerProxy>
  #                 <hashTree/>
  #                 <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
  #                   <collectionProp name="HeaderManager.headers">
  #                     <elementProp name="" elementType="Header">
  #                       <stringProp name="Header.name">Content-Type</stringProp>
  #                       <stringProp name="Header.value">application/json</stringProp>
  #                     </elementProp>
  #                     <elementProp name="" elementType="Header">
  #                       <stringProp name="Header.name">x-api-key</stringProp>
  #                       <stringProp name="Header.value">${{ secrets.API_KEY }}</stringProp> <!-- Using the secret here -->
  #                     </elementProp>
  #                   </collectionProp>
  #                 </HeaderManager>
  #                 <hashTree/>
  #               </hashTree>
  #             </hashTree>
  #           </hashTree>
  #         </jmeterTestPlan>' > test_plan.jmx

  #     # Run JMeter Performance Test
  #     - name: Run JMeter Performance Test
  #       run: |
  #         /opt/jmeter/bin/jmeter -n -t test_plan.jmx -l results.jtl -e -o /opt/jmeter/reports

  #     # Upload JMeter Results as artifact
  #     - name: Upload JMeter Results
  #       uses: actions/upload-artifact@v3
  #       with:
  #         name: jmeter-report
  #         path: /opt/jmeter/reports
